# あなたは RPG のダンジョンの設計をしています。

# そのダンジョンには N 個の部屋が用意されており、それぞれの部屋は 1, 2, ..., N で表されます。このダンジョンでは 1 部屋に 1 プレイヤーしか滞在できません。
# また、プレイヤーは M 人いて、現在 i (1 ≦ i ≦ M) 番目のプレイヤーは部屋 S_i (1 ≦ S_i ≦ N) に滞在しています。

# ダンジョンをクリアするには、プレイヤーはそれぞれ、部屋を移動する必要があります。

# M 人のプレイヤーはそれぞれ、移動先の部屋の候補を検討しています。具体的には、i (1 ≦ i ≦ M) 番目のプレイヤーは移動先の部屋の候補として部屋 T_i (1 ≦ T_i ≦ N) を検討しています。ここで、T_i は相異なる整数です。すなわち、異なる 2 人のプレイヤーの移動先の部屋の候補が同じ部屋になることはありません。

# しかし、部屋の移動は各プレイヤーが部屋を移動しようと思っても、その部屋はまだ別のプレイヤーが滞在しているかもしれません。その場合はプレイヤーは部屋を移動することができません。移動先にいるプレイヤーが先に移動するのを待つ必要があります。同じタイミングで同時に移動をおこなうことはできません。


# そこで、移動先の候補の部屋にプレイヤーがいる場合は、そのプレイヤーが自身の移動先の候補の部屋に移動した後に移動をすることにしました。

# あなたの仕事は、1 番目のプレイヤーの移動を完了させるために移動をすることになるプレイヤーの番号を順番に全て求めることです。

# ただし、滞在している部屋と移動先の部屋が同じ場合、つまり S_i = T_i (1 ≦ i ≦ M) の場合、そのプレイヤーは移動ができることとします。また、部屋の移動を繰り返すことで 1 番目のプレイヤーが必ず移動できることが保証されます。


n, m = map(int, input().split())

room = [-1] * (n + 1)
req = [-1] * (m + 1)
for i in range(m):
    s, t = map(int, input().split())
    room[s] = i + 1
    req[i + 1] = t

q = [1]
while True:
    p = q[-1]

    if room[req[p]] == -1:
        break
    if room[req[p]] == p:
        break

    q.append(room[req[p]])

print(" ".join(map(str, reversed(q))))

# 答えを表す配列 players を用意し、部屋の移動をするプレイヤーを変数 P で保存します。P の初期値は 1 とします。
# 移動先の部屋が空くまで、players に P を追加し、P に "移動先の部屋に滞在しているプレイヤー" を代入することを繰り返します。
# 部屋を移動できるかの判定や、移動先の部屋に滞在しているプレイヤーの番号の取得は、以下のようにします。
# それぞれの席に滞在しているプレイヤーの番号を配列 room[] で管理します。
# room[T_P] で、移動先の部屋に滞在しているプレイヤーの番号が得られます。
# room[T_P] == 0 で、移動先の部屋にプレイヤーが滞在していないことを判定できます。
# 移動先のプレイヤーから順に部屋の移動をするため、players は逆順で出力します。