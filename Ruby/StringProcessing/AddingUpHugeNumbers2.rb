s = gets.to_i
t = gets.to_i

puts s + t

# Rubyはオーバーフローが起きない

# S , T を数値として扱うとオーバーフローが発生します。
# そこで、S , T を それぞれ文字列として受け取り計算を行います。
# また、答えとなる値も数値として扱うことはできないので、答えとなる数字も文字列として扱う必要があります。
# 今回の計算では、繰り上がりはおこる可能性があるので S + T の答え ans の各桁の計算結果である ans[i] について次の関係が成り立ちます。
# ans[i] = S[i] + T[i] + (下位からの繰り上がり）
# 10 <= ans[i] の時、繰り上がりが発生します。
# 上位の桁への繰り上がりは ans[i] の 10 の位、すなわち ans[i]/10
# 計算結果のその桁の答えとなる数字は ans[i] の 1 の位、すなわち ans[i]%10 です。
# 繰り上がりの値を保持して計算を行うことで、順に繰り上がりを処理することができます。
# 繰り上がりは下位の位から順に発生するので、下位から順に足し算を行う必要があります。
# 最上位の桁の計算結果に注意する必要があります。
# 最上位の桁の足し算で繰り上がりが発生した場合、最後にその繰り上がりの数字を新たに答えに追加する必要があるので気をつけてください。
# 例) 345 + 785 = `1`130

# C++
# 方針の通り、文字列と数字の変換を用いて各桁について足し算を行います。
# 文字列と数値の変換が度々出てくるので気をつけてください。

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(){
    string S,T,ans = "";
    int add,up = 0;
    cin >> S;
    cin >> T;

    for(int i=S.size()-1;0<=i;--i){
        add = S[i]-'0'+ T[i]-'0' + up;
        up = add/10;
        ans += to_string(add%10);
    }

    if(0 < up){
        ans += to_string(up);
    }

    reverse(ans.begin(),ans.end());

    cout << ans << endl;
}
